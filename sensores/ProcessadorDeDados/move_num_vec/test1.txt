# usac03

# int* array » %rdi
# int length » %esi
# int *read » %rdx
# int *write » %rcx
# int num » %r8d
# int* vec » %r9

.section .text
	.global move_num_vec
	
move_num_vec:
	movq $0, %rax						# Colocar retorno a 0, para evento de NÃO copia do vetor
	cmpl %esi, %r8d						# Comparar length com num
	jg end								# Se num for superior a length, jmp para end

move_and_remove:
	cmpl $0, %r8d						# Compara num com 0
	je end_moved
	decl %r8d							
	
	movslq (%rdx), %rax
	addl $1, (%rdx)						# Incrementa 1 ao indice do iterador read
	movl (%rdi,%rax,4), %r10d			# Copia valor rdi no indice indicado por (rdx) de 4bytes para registo 32bit
	movl %r10d, (%r9)					# Copia valor em registo 32bit para indice atual de vec
	movslq (%rcx), %rax
	addl $1, (%rcx)						# Incrementa 1 ao indice do iterador write
	movq $0, (%rdi,%rax,4)				# Coloca a zero o endereço em write
		
	cmpl %esi, (%rdx)					# Compara valor de read com length
	jl skip_read_to_zero				
	movl $0, (%rdx)						# Atribui o valor de 0 a read, pois chegou ao limite do array(buffer)

skip_read_to_zero:
	cmpl %esi, (%rcx)					# Compara valor de write com length
	jl skip_write_to_zero
	movl $0, (%rcx)						# Atribui o valor de 0 a write, pois chegou ao limite do array(buffer)
	
skip_write_to_zero:
	addq $4, %r9						# Move para o próximo endereço/indice de vec
	jmp move_and_remove
	
end_moved:	
	movq $1, %rax						# Atribui o valor de 1 ao retorno indicando que houve movimentação de valores
	
end:
	ret






**********************





# usac03

# int* array » %rdi
# int length » %esi
# int *read » %rdx
# int *write » %rcx
# int num » %r8d
# int* vec » %r9

.section .text
	.global move_num_vec
	
move_num_vec:
	movq $0, %rax						# Colocar retorno a 0, para evento de NÃO cópia do vetor
	cmpl %esi, %r8d						# Comparar length com num
	jg end								# Se num for superior a length, jmp para end

look_valid:	 
	movslq (%rdx), %r10					# Colocar o indice apontado por read no registo
	cmpl $0, (%rdi,%r10,4)				# Compara o valor apontado por read com 0, saltar a cópia do valor se for 0
	je skip_write

write:
	movq $1, %rax						# Atribui o valor de 1 ao retorno indicando que houve movimentação de valores
	movslq (%rcx), %r10					# Colocar o indice apontado por write no registo
	movl (%rdi,%r10,4), %r11d			# Colocar o valor apontado pelo indice de write num registo
	movl %r11d, (%r9)					# Coloca o valor no registo para a posição atual em vec
	addq $4, %r9
	jmp skip_nullify

skip_write:
	movslq (%rcx), %r10					# Colocar o indice apontado por write no registo
	movl $0, (%rdi,%r10,4)				# Coloca 0 no array, para a posição apontada por write

skip_nullify:
	addl $1, (%rcx)						# Incrementa 1 ao indice do iterador write
	addl $1, (%rdx)						# Incrementa 1 ao indice do iterador read

	cmpl %esi, (%rdx)					# Compara valor de read com length, e volta ao loop se for inferior
	jl look_valid
	
end:
	ret





****************************



# usac03

# int* array » %rdi
# int length » %esi
# int *read » %rdx
# int *write » %rcx
# int num » %r8d
# int* vec » %r9

.section .text
	.global move_num_vec
	
move_num_vec:

	pushq %rbx

	movq $0, %rax						# Colocar retorno a 0, para evento de NÃO cópia do vetor
	cmpl %esi, %r8d						# Comparar length com num
	jg end
	movl (%rcx), %r11d					# Copia valor de read original para registo 32bit
	
loop:
	movl (%rdx), %r10d					# Colocar valor em read para registo
	cmpl %r10d, (%rcx)					# Compara valor em write com valor em read
	jne write							# Salta para escrita,se for inferior
	
read:
	movslq (%rdx), %r10					# Coloca o valor em read num registo
	cmpl $0, (%rdi,%r10,4)				# Compara o valor no indice de read do array a 0
	je skip_vec							# Se for 0, salta a cópia
	
copy:
	movq $1, %rax						# Coloca 1 no retorno, validando a copia dos n números
	movl (%rdi,%r10,4), %ebx			# Copia valor no indice write do array para registo
	movl %ebx, (%r9)					# Copia valor do registo para vec
	subl $1, %r8d						# Decrementa o num em 1
	cmpl $0, %r8d						# Compara num a 0
	je skip_vec							# Salta para write se tiver preenchido vec
	addq $4, %r9						# Avança para próximo endereço/indice de vec
	
skip_vec:
	addl $1, (%rdx)						# Adiciona 1 a read
	cmpl %esi, (%rdx)					# Compara valor atual em read a length
	jl write

readtozero:
	movl $0, (%rdx)						# Coloca read a 0
	
write:
	movslq (%rcx), %r10					# Coloca o valor em write num registo
	movl $0, (%rdi,%r10,4)				# Coloca a zero no indice write do array
	addl $1, (%rcx)						# Adiciona 1 a write
	cmpl %esi, (%rcx)					# Compara valor atual em write a length
	jl full_loop						# Se não forem iguais, salta para testar se fez loop completo
	
writetozero:
	movl $0, (%rcx)						# Coloca write a 0

full_loop:
	cmpl %r11d, (%rcx)					# Compara o indice atual de read com o seu valor inicial
	je end								# Salta para o final se tiver completado uma volta
	jmp loop
	
end:
	popq %rbx
	ret